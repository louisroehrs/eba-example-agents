version: 6
meta:
  name: Spotifinder
  icon: 'https://www.ibm.com/watson/music/noteasy/images/image-00.png'
  description: |-
    - what albums does the track "Someday" appear on?
    - show me playlists for category "party"
    - show me all categories
    - show me "madonna"
settings:
  - name: spotAuthUrl
    value: 'https://accounts.spotify.com/api/token'
secrets:
  - name: spotClientSecret
  - name: spotClientId
concepts:
  - name: 'spot:Video'
  - name: 'spot:Image'
  - name: 'spot:ArtistName'
  - name: 'spot:Asset'
    ontology:
      isSpellAs: asset
      subClassOf: ':Showable'
  - name: 'spot:Relation'
  - name: 'spot:Assets'
    ontology:
      isSpellAs: assets|*
      isListOf: 'spot:Asset'
      subClassOf: ':Showable'
  - name: 'spot:Artists'
    ontology:
      isSpellAs: artists|*
  - name: 'spot:Artist'
    ontology:
      isSpellAs: artist
      subClassOf: 'spot:AssetType'
  - name: 'spot:Tracks'
    ontology:
      isSpellAs: tracks|*
  - name: 'spot:AssetType'
  - name: 'spot:SearchResults'
    ontology:
      isSpellAs: search results
      subClassOf: ':Showable'
  - name: ':UserText'
  - name: ':FreeText'
  - name: ':Relation'
    ontology:
      isSpellAs: for
      subClassOf: 'spot:Relation'
  - name: 'spot:Track'
    ontology:
      isSpellAs: track
      subClassOf: 'spot:AssetType'
  - name: 'spot:Album'
    ontology:
      isSpellAs: album
      subClassOf: 'spot:AssetType'
  - name: 'spot:Albums'
    ontology:
      isSpellAs: albums|*
  - name: ':WithName'
  - name: ':Filter'
    ontology:
      subClassOf: 'spot:Relation'
  - name: 'spot:CategoryId'
  - name: 'spot:Category'
    ontology:
      isSpellAs: ' category'
    attributes:
      'spot:CategoryId': id
      'spot:CategoryName': name
  - name: 'spot:CategoryName'
    ontology:
      subClassOf: ':UserString'
  - name: 'spot:Playlists'
    ontology:
      isListOf: 'spot:Playlist'
      subClassOf: ':Showable'
      isSpellAs: playlists|*
  - name: 'spot:Country'
    ontology:
      isSpellAs: country
  - name: 'spot:Playlist'
    ontology:
      isSpellAs: playlist
      subClassOf: ':Showable'
    attributes:
      'spot:PlaylistName': name
  - name: 'spot:PlaylistName'
  - name: ':Showable'
  - name: ':All'
    ontology:
      isSpellAs: all
  - name: 'spot:Categories'
    ontology:
      isListOf: 'spot:Category'
      isSpellAs: categories|*
      subClassOf: ':Showable'
  - name: ':UserString'
  - name: 'spot:SearchQuery'
    ontology:
      subClassOf: ':UserString'
  - name: ':ActionShow'
patterns: "<!--\n\tEnter your NL patterns in this markdown panel. \n\tA pattern consists of natural language text annotated with concepts tags. \n\tFor example,\n\t 'tell me a [joke](demo:Joke)' annotates the demo:Joke concept appropriately\n\t 'show me the [weather](demo:Weather)' annotates the demo:Weather concept appropriately. \n\tWe even support regular expression annotations.\n\t For example, '[`REGEX [0-9]{5}`](demo:ZIPCode)' provides a zip code annotation.\n-->\n<!--\n\tEnter your NL patterns in this markdown panel. \n\tA pattern consists of natural language text annotated with concepts tags. \n\tFor example,\n\t 'tell me a [joke](demo:Joke)' annotates the demo:Joke concept appropriately\n\t 'show me the [weather](demo:Weather)' annotates the demo:Weather concept appropriately. \n\tWe even support regular expression annotations.\n\t For example, '[`REGEX [0-9]{5}`](demo:ZIPCode)' provides a zip code annotation.\n-->\n- what [albums](spot:Albums) does the track “Someday” appear on?\n- show me [playlists](spot:Playlists) for category Jazz\n- show me [categories](spot:Categories)\n- [find me](spot:SearchResults) (spot:SearchQuery)\n- [dig up](spot:SearchResults) (spot:SearchQuery)\n- find [tracks](spot:Tracks), [artists](spot:Artists), [albums](spot:Albums)  called \"something\"\n- show me [tracks](spot:Tracks), [artists](spot:Artists), [albums](spot:Albums)  for something\n- show me [tracks](spot:Tracks) for The Wall\n- show me [albums](spot:Albums) by Madonna\n- [search for](spot:SearchResults) query\n- show me the [track](spot:Track), the [artist](spot:Artist), and the [album](spot:Album) \n\n\n"
actions:
  - name: 'spot:GetAnything'
    signature: >-
      type subClassOf spot:AssetType, relational subClassOf spot:Relation =>
      spot:Assets (optional :All, type, optional relational (data :FreeText)) ->
      data spot:Assets
    kind: 'nodejs:10'
    code: |
      const eba = require("eba")
      const request = require("request-promise-native")
            
      module.exports = async function main(params) {
        let p = new eba.Params(params)
        let type = p.get(":FreeString").toLowerCase()
      // let country = p.get("spot:Country")
        
        let pathListview = `https://api.spotify.com/v1/browse/categories/${type}/playlists`
              
        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token: " + access_token
        progress += " Category:" + JSON.stringify(category)
        progress += "Path: " + pathListview
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Assets", results[type+"s"].items)
          }
        )
        .catch(function (error) {
          return { error: `No playlists were found for "${p.get(":UserString")}"` }
          //return { error: `API error: ${error}  Progress: ${progress}` }
        })
      };
    notes: in progress. just rying to get the damn thing to trigger
    active: true
  - name: 'spot:GetAlbumsByArtist'
    signature: 'spot:Albums (:Relation (data :FreeText)) -> data spot:Albums'
    kind: 'nodejs:10'
    code: |
      const eba = require("eba")
      const request = require("request-promise-native")
            
      module.exports = async function main(params) {
        let p = new eba.Params(params)
        let searchquery = p.get(":UserString").toLowerCase()
      // let country = p.get("spot:Country")
        
        let pathListview = `https://api.spotify.com/v1/search?q=${encodeURIComponent(searchquery)}&type=album`

        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token: " + access_token
        progress += " Category:" + JSON.stringify(category)
        progress += "Path: " + pathListview
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Albums", results.playlists.items)
          }
        )
        .catch(function (error) {
          return { error: `No albums were found for "${p.get(":UserString")}"` }
          //return { error: `API error: ${error}  Progress: ${progress}` }
        })
      }
    notes: not yet
    active: true
  - name: 'spot:GetPlaylists'
    signature: 'spot:Playlists (:Relation (data :FreeText)) -> data spot:Playlists'
    kind: 'nodejs:10'
    code: |-
      const eba = require("eba")
      const request = require("request-promise-native")
            
      async function main(params) {
        let p = new eba.Params(params)
        let category = p.get(":FreeText").toLowerCase()
      // let country = p.get("spot:Country")
        
        let pathListview = `https://api.spotify.com/v1/browse/categories/${category}/playlists`
              
        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token: " + access_token
        progress += " Category:" + JSON.stringify(category)
        progress += "Path: " + pathListview
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Playlists", results.playlists.items)
          }
        )
        .catch(function (error) {
          return { error: `No playlists were found for "${p.get(":UserString")}"` }
          //return { error: `API error: ${error}  Progress: ${progress}` }
        })
      }
      module.exports = {main}
    notes: works
    active: true
  - name: 'spot:GetCategories'
    signature: 'spot:Categories (optional :All) -> data spot:Categories'
    kind: 'nodejs:10'
    code: |-
      const eba = require("eba")
      const request = require("request-promise-native")
            
      async function main(params) {
              
        let pathListview = "https://api.spotify.com/v1/browse/categories"
              
        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token" + access_token
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Categories", results.categories.items)
          }
        )
        .catch(function (error) {
          return { error: `API error: ${error}  Progress: ${progress}` }
        })
      }
      module.exports = {main}
    notes: works
    active: true
  - name: 'spot:SearchAction'
    signature: 'spot:SearchResults (data :UserString) -> data spot:SearchResults'
    kind: 'nodejs:10'
    code: |+
      const eba = require("eba")
      const request = require("request-promise-native")
        
        
         
      module.exports.main = async (params) => {
        let p = new eba.Params(params)
        let searchquery = p.get(":UserString")


      // let country = p.get("spot:Country")
        
        let options = {
            uri:  `https://api.spotify.com/v1/search?q=${encodeURIComponent(searchquery)}&type=artist,album,track`,
            headers: {
              "Authorization": "Bearer " + params.storage["token"]
            },
            json: true 
          }
          
        let progress = "Status: Reached query"
        progress += " Access Token: " + options.headers.Authorization
        progress += " Search:" + JSON.stringify(searchquery)
        progress += "Path: " + options.uri
        
        return request(options)
          .then((result) => {
            let items = []
            items.push({id:"searching for", "name": `searching for "${searchquery}" `,"type":"all"})
            if (result.artists) {
              items.push(...result.artists.items)
            }
            if (result.albums) {
              items.push(...result.albums.items)
            }
            if (result.tracks) {
              items.push(...result.tracks.items)
            }
            if (items.length > 0) {
              return new eba.Result().setData("spot:SearchResults", items)
            } else return {error:`SPOT: No results found for "${searchquery}"` } 
          }
        )
        .catch(function (error) {
          //return { error: `No search results were found for "${p.get(":UserString")}"` }
          return { error: `SPOT: API error: ${error}  Progress: ${progress}` }
        })
      }

    notes: show me "search"
    active: true
rules:
  - name: 'spot:ArtistAssets'
    signature: 'spot:Artists -> spot:Assets (spot:Artist)'
  - name: 'spot:AlbumAssets'
    signature: 'spot:Albums -> spot:Assets (spot:Album)'
  - name: 'spot:TrackAssets'
    signature: 'spot:Tracks -> spot:Assets (spot:Track)'
endpoints:
  - name: '@start'
    kind: 'nodejs:10'
    code: |
      const eba = require('eba');
      const request = require("request-promise-native")

      async function main(params) {
        var options = {
          uri: params.settings["spotAuthUrl"],
          form: "grant_type=client_credentials",
          headers: {
            "Authorization": "Basic " + Buffer.from(`${params.secrets.spotClientId}:${params.secrets.spotClientSecret}`).toString('base64')
          },
          json: true
        }
              
        let progress = " Status: Preparing request to " + params.settings["spotAuthUrl"]
        progress += Buffer.from(`${params.secrets.spotClientId}:${params.secrets.spotClientSecret}`).toString('base64') + ` ${params.secrets.spotClientId}:${params.secrets.spotClientSecret}` 
                
        return request.post(options)
          .then(function(body) {
            var access_token = body.access_token
            progress += " Access Token: " + access_token
            return new eba.Result().store('token', access_token);
          }
        ).catch(function (error) {
          return { error: `API error: ${error}  Progress: ${progress}` }
        })
      };

      module.exports = {main}
statics:
  - name: spot/searchresults.jsx
    mime: text/jsx
    text: |-
      spot_SearchResultsData = ({data}) => {
        return (
          <div className="wmt-products">
           { data.map((item) =>
              React.createElement(
                spot_SearchResultData,
                {data:item})) }
          </div>
          )
      }

      //React.createElement(
      //          spot_SearchResultData,
      //          {data:item})) }
      /*if (item.type == "album"){
                React.createElement(
                  spot_AlbumData,
                  {data:item})
              }
              if (item.type == "artist"){ 
                React.createElement(
                  spot_ArtistData,
                  {data:item})
              }*/

      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_SearchResultData = ({data}) => {
        const item = data;
        console.log("dd"+JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product">
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{item.type}</p>
              </div> 
            </div>
          </div>)
      }


      // the datasets seem to be located at <host>/resource/<datasetid>.json
      /*
      spot_AlbumData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  >
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong> by {item.external_urls[0].name}</p> 
                <p>{item.type}</p>
              </div> 
            </div>
          </div>)
      }

      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_ArtistData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  >
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{item.type}</p>
              </div> 
            </div>
          </div>)
      }
      */
         
      spot_link = ({linky}) => {
        const link = linky
        return (<a href={'"'+link+'"'} target='_blank'>{link}</a>)
      }

      spot_decodeHTMLEntities = (encoded) => {
        if (encoded) {
          var elem = document.createElement('textarea')
          elem.innerHTML = encoded.replace(/[\uFFFD]/g,' ')
          return elem.value
        }
        else return ""
      }
    frontend: true
  - name: spot/playlists.jsx
    mime: text/jsx
    text: |
      spot_PlaylistsData = ({data}) => {
        return (
          <div className="wmt-products">
            { 
                data.map((item) =>
                  React.createElement(
                    spot_PlaylistData,
                    {data:item}))
              }
          </div>)
      }

      spot_PlaylistsContent = ({data}) => {
        return (
          <div className="wmt-products">
            { 
                data.map((item) =>
                  React.createElement(
                    spot_PlaylistContent,
                    {data:item}))
              }
          </div>)
      }

      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_PlaylistContent = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product" style={{float:'left'}}>
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong> {item.tracks.total}</p> 
                <img src={item.images[0].url}/>
              </div> 
            </div>
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_PlaylistData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product">
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong> {item.tracks.total}</p> 
                <img src={item.images[0].url}/>
              </div> 
            </div>
          </div>)
      }

      spot_link = ({linky}) => {
        const link = linky
        return (<a href={'"'+link+'"'} target='_blank'>{link}</a>)
      }

      spot_decodeHTMLEntities = (encoded) => {
        if (encoded) {
          var elem = document.createElement('textarea')
          elem.innerHTML = encoded.replace(/[\uFFFD]/g,' ')
          return elem.value
        }
        else return ""
      }
    frontend: true
  - name: spot/category.css
    mime: text/css
    text: |-
      .wmt-product {
        margin-bottom: 20px;
      }
      .wmt-product:last-child {
        margin-bottom: 0;
      }
      .wmt-product-info {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .wmt-product-info img {
        max-width: 100px;
        margin-right: 15px;
      }
      .wmt-product-discount {
        color: red;
      }
      .wmt-product-info-description {
        display: block;
        overflow: hidden;
        line-height: 16px;
        max-height: calc(16px * 5);
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 5;
      }
    frontend: true
  - name: spot/categories.jsx
    mime: text/jsx
    text: |-
      spot_CategoriesData = ({data}) => {
        return (
          <div className="wmt-products">
            { data.map((item) =>
              React.createElement(
                spot_CategoryData,
                {data:item})) }
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_CategoryData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  onClick={function() {bridge.trigger("ask","show me playlists for category \"" + item.name+"\"")}} >
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{true||React.createElement(spot_link,{linky:item.href})}</p>
                <img src={item.icons[0].url}/>

              </div> 
            </div>
          </div>)
      }


      spot_CategoriesContent = ({data}) => {
        return (
          <div className="wmt-products">
            { data.map((item) =>
              React.createElement(
                spot_CategoryContent,
                {data:item})) }
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_CategoryContent = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  onClick={function() {bridge.trigger("ask","show me playlists for category \"" + item.name+"\"")}} style={{float:'left'}}>
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{true||React.createElement(spot_link,{linky:item.href})}</p>
                <img src={item.icons[0].url}/>

              </div> 
            </div>
          </div>)
      }
      spot_cat_click = (name)=> {
         return 'bridge.trigger("ask","show me playlists for "'+name+'")';
      }
         
      spot_link = ({linky}) => {
        const link = linky
        return (<a href={'"'+link+'"'} target='_blank'>{link}</a>)
      }

      spot_decodeHTMLEntities = (encoded) => {
        if (encoded) {
          var elem = document.createElement('textarea')
          elem.innerHTML = encoded.replace(/[\uFFFD]/g,' ')
          return elem.value
        }
        else return ""
      }
    frontend: true
