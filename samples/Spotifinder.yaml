version: 6
meta:
  name: Spotifinder
  icon: 'https://www.ibm.com/watson/music/noteasy/images/image-00.png'
settings:
  - name: spotAuthUrl
    value: 'https://accounts.spotify.com/api/token'
secrets:
  - name: spotClientSecret
  - name: spotClientId
concepts:
  - name: ':WithName'
  - name: ':Filter'
  - name: 'spot:CategoryId'
  - name: 'spot:Category'
    attributes:
      'spot:CategoryId': id
      'spot:CategoryName': name
  - name: 'spot:CategoryName'
    ontology:
      subClassOf: ':UserString'
  - name: 'spot:Playlists'
    ontology:
      isListOf: 'spot:Playlist'
      subClassOf: ':Showable'
      isSpellAs: playlists|*
  - name: 'spot:Country'
    ontology:
      isSpellAs: country
  - name: 'spot:Playlist'
    ontology:
      isSpellAs: playlist
      subClassOf: ':Showable'
    attributes:
      'spot:PlaylistName': name
  - name: 'spot:PlaylistName'
  - name: ':Showable'
  - name: ':All'
    ontology:
      isSpellAs: all
  - name: 'spot:Categories'
    ontology:
      isListOf: 'spot:Category'
      isSpellAs: categories|*
      subClassOf: ':Showable'
  - name: ':UserString'
  - name: 'spot:SearchQuery'
  - name: 'spot:SearchDocs'
    ontology:
      subClassOf: ':Showable'
  - name: ':ActionShow'
patterns: "<!--\n\tEnter your NL patterns in this markdown panel. \n\tA pattern consists of natural language text annotated with concepts tags. \n\tFor example,\n\t 'tell me a [joke](demo:Joke)' annotates the demo:Joke concept appropriately\n\t 'show me the [weather](demo:Weather)' annotates the demo:Weather concept appropriately. \n\tWe even support regular expression annotations.\n\t For example, '[`REGEX [0-9]{5}`](demo:ZIPCode)' provides a zip code annotation.\n-->\n<!--\n\tEnter your NL patterns in this markdown panel. \n\tA pattern consists of natural language text annotated with concepts tags. \n\tFor example,\n\t 'tell me a [joke](demo:Joke)' annotates the demo:Joke concept appropriately\n\t 'show me the [weather](demo:Weather)' annotates the demo:Weather concept appropriately. \n\tWe even support regular expression annotations.\n\t For example, '[`REGEX [0-9]{5}`](demo:ZIPCode)' provides a zip code annotation.\n-->\n- show me [playlists](spot:Playlists) for category\n- show me [categories](spot:Categories)\n- [search](spot:SearchDocs)  [for](spot:SearchQuery)\n"
actions:
  - name: 'spot:GetPlaylists'
    signature: >-
      spot:Playlists (context spot:Category, optional spot:Category (data
      :UserString)) -> data spot:Playlists
    kind: 'nodejs:10'
    code: |-
      const eba = require("eba")
      const request = require("request-promise-native")
            
      async function main(params) {
        let p = new eba.Params(params)
        let category = p.get(":UserString").toLowerCase()
      // let country = p.get("spot:Country")
        
        let pathListview = `https://api.spotify.com/v1/browse/categories/${category}/playlists`
              
        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token: " + access_token
        progress += " Category:" + JSON.stringify(category)
        progress += "Path: " + pathListview
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Playlists", results.playlists.items)
          }
        )
        .catch(function (error) {
          return { error: `No playlists were found for "${p.get(":UserString")}"` }
          //return { error: `API error: ${error}  Progress: ${progress}` }
        })
      }
      module.exports = {main}
  - name: 'spot:GetCategories'
    signature: 'spot:Categories (optional :All) -> data spot:Categories'
    kind: 'nodejs:10'
    code: |-
      const eba = require("eba")
      const request = require("request-promise-native")
            
      async function main(params) {
              
        let pathListview = "https://api.spotify.com/v1/browse/categories"
              
        let progress = "Status: Reached query"
        
        let access_token= params.storage["token"]
        progress += " Access Token" + access_token
        return request
          .get({
            uri:  pathListview,
            headers: {
              "Authorization": "Bearer " + access_token
            }
          })
          .then(JSON.parse)
          .then(function(results) {
            return new eba.Result().setData("spot:Categories", results.categories.items)
          }
        )
        .catch(function (error) {
          return { error: `API error: ${error}  Progress: ${progress}` }
        })
      }
      module.exports = {main}
  - name: 'spot:SearchAction'
    signature: >-
      spot:SearchDocs (optional spot:SearchQuery (data :UserString)) -> data
      spot:SearchDocs
    kind: 'nodejs:10'
    code: |-
      const request = require('request-promise-native')
      const eba = require('eba')

      module.exports.main = function (params) {
        let h = new eba.Params(params)
        let searchquery = h.get(":UserString")

        let options = {
          uri: `https://api.spotify.com/service/v1/search/select?q=${encodeURIComponent(searchquery)}`,
         
          headers: {
              'User-Agent': 'Request-Promise',
              'Accept' : 'application/json',
              'ESSAuthorization':`Basic NTIzMDFhY2QtYWM1ZC00NTM5LWI1NWQtYTAxNGYzNjA3MWE1`
          },
          json: true // Automatically parses the JSON string in the response
        };


        return request(options)
          .then((result) => {
            if (result.numFound >0 && result.searchResults.length>0) {
              return new eba.Result().setData('wps:SearchDocs',result.searchResults)
            } else {
              return {error: `No search docs found ${result.numFound} ${result.searchResults.length}`}
            }
          })
          .catch((error) => {
            return { error: `WPS:Search API error search: ${error}` }
          })
          
      }
endpoints:
  - name: '@start'
    kind: 'nodejs:10'
    code: |
      const eba = require('eba');
      const request = require("request-promise-native")

      async function main(params) {
        var options = {
          uri: params.settings["spotAuthUrl"],
          form: "grant_type=client_credentials",
          headers: {
            "Authorization": "Basic " + Buffer.from(`${params.secrets.spotClientId}:${params.secrets.spotClientSecret}`).toString('base64')
          },
          json: true
        }
              
        let progress = " Status: Preparing request to " + params.settings["spotAuthUrl"]
        progress += Buffer.from(`${params.secrets.spotClientId}:${params.secrets.spotClientSecret}`).toString('base64') + ` ${params.secrets.spotClientId}:${params.secrets.spotClientSecret}` 
                
        return request.post(options)
          .then(function(body) {
            var access_token = body.access_token
            progress += " Access Token: " + access_token
            return new eba.Result().store('token', access_token);
          }
        ).catch(function (error) {
          return { error: `API error: ${error}  Progress: ${progress}` }
        })
      };

      module.exports = {main}
statics:
  - name: spot/playlists.jsx
    mime: text/jsx
    text: |
      spot_PlaylistsData = ({data}) => {
        return (
          <div className="wmt-products">
            { 
                data.map((item) =>
                  React.createElement(
                    spot_PlaylistData,
                    {data:item}))
              }
          </div>)
      }

      spot_PlaylistsContent = ({data}) => {
        return (
          <div className="wmt-products">
            { 
                data.map((item) =>
                  React.createElement(
                    spot_PlaylistContent,
                    {data:item}))
              }
          </div>)
      }

      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_PlaylistContent = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product" style={{float:'left'}}>
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong> {item.tracks.total}</p> 
                <img src={item.images[0].url}/>
              </div> 
            </div>
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_PlaylistData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product">
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong> {item.tracks.total}</p> 
                <img src={item.images[0].url}/>
              </div> 
            </div>
          </div>)
      }

      spot_link = ({linky}) => {
        const link = linky
        return (<a href={'"'+link+'"'} target='_blank'>{link}</a>)
      }

      spot_decodeHTMLEntities = (encoded) => {
        if (encoded) {
          var elem = document.createElement('textarea')
          elem.innerHTML = encoded.replace(/[\uFFFD]/g,' ')
          return elem.value
        }
        else return ""
      }
    frontend: true
  - name: spot/category.css
    mime: text/css
    text: |-
      .wmt-product {
        margin-bottom: 20px;
      }
      .wmt-product:last-child {
        margin-bottom: 0;
      }
      .wmt-product-info {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .wmt-product-info img {
        max-width: 100px;
        margin-right: 15px;
      }
      .wmt-product-discount {
        color: red;
      }
      .wmt-product-info-description {
        display: block;
        overflow: hidden;
        line-height: 16px;
        max-height: calc(16px * 5);
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 5;
      }
    frontend: true
  - name: spot/categories.jsx
    mime: text/jsx
    text: |-
      spot_CategoriesData = ({data}) => {
        return (
          <div className="wmt-products">
            { data.map((item) =>
              React.createElement(
                spot_CategoryData,
                {data:item})) }
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_CategoryData = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  onClick={function() {bridge.trigger("ask","show me playlists for category \"" + item.name+"\"")}} >
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{true||React.createElement(spot_link,{linky:item.href})}</p>
                <img src={item.icons[0].url}/>

              </div> 
            </div>
          </div>)
      }


      spot_CategoriesContent = ({data}) => {
        return (
          <div className="wmt-products">
            { data.map((item) =>
              React.createElement(
                spot_CategoryContent,
                {data:item})) }
          </div>)
      }
      // the datasets seem to be located at <host>/resource/<datasetid>.json
      spot_CategoryContent = ({data}) => {
        const item = data
        console.log(JSON.stringify(item));
        return (
          <div key={item.id} className="wmt-product"  onClick={function() {bridge.trigger("ask","show me playlists for category \"" + item.name+"\"")}} style={{float:'left'}}>
            <div className="wmt-product-info">
              <div className="wmt-product-info-name">
                <p><strong>{item.name}</strong></p> 
                <p>{true||React.createElement(spot_link,{linky:item.href})}</p>
                <img src={item.icons[0].url}/>

              </div> 
            </div>
          </div>)
      }
      spot_cat_click = (name)=> {
         return 'bridge.trigger("ask","show me playlists for "'+name+'")';
      }
         
      spot_link = ({linky}) => {
        const link = linky
        return (<a href={'"'+link+'"'} target='_blank'>{link}</a>)
      }

      spot_decodeHTMLEntities = (encoded) => {
        if (encoded) {
          var elem = document.createElement('textarea')
          elem.innerHTML = encoded.replace(/[\uFFFD]/g,' ')
          return elem.value
        }
        else return ""
      }
    frontend: true
